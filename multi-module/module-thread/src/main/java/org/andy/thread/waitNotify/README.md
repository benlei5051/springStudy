https://blog.csdn.net/u010870518/column/info/17790



关键字synchronized取得的锁都是对象锁，而不是把一段代码或方法当做锁，
哪个线程先执行synchronized 关键字的方法，那个线程就持有该方法所属对象的锁，
两个对象，线程获得的就是两个不同对象的不同的锁，他们互不影响的。

一、wait方法

（1）方法wait()的作用是使当前执行代码的线程进行等待，该方法会将该线程放入”预执行队列“中，并且在wait()所在的代码处停止执行，直到接到通知或被中断为止。

（2）在调用wait()之前，线程必须获得该对象级别锁，这是一个很重要的地方，很多时候我们可能会忘记这一点，即只能在同步方法或同步块中调用wait()方法。

（3）还需要注意的是wait()是释放锁的，即在执行到wait()方法之后，当前线程会释放锁，当从wait()方法返回前，线程与其他线程竞争重新获得锁。

二、notify方法

（1）和wait()方法一样,notify()方法也要在同步块或同步方法中调用，即在调用前，线程也必须获得该对象的对象级别锁。

（2）该方法是用来通知那些可能等待该对象的对象锁的其他线程，如果有多个线程等待，则由线程规划器随机挑选出其中一个呈wait状态的线程，对其发出通知notify，并使它等待获取该对象的对象锁。

（3）这里需要注意的是，执行notify方法之后，当前线程不会立即释放其拥有的该对象锁，而是执行完之后才会释放该对象锁，被通知的线程也不会立即获得对象锁，而是等待notify方法执行完之后，释放了该对象锁，才可以获得该对象锁。

（3）notifyAll()通知所有等待同一共享资源的全部线程从等待状态退出，进入可运行状态，重新竞争获得对象锁。

三、wait()/notify()方法总结

（1）wait()/notify()要集合synchronized关键字一起使用，因为他们都需要首先获取该对象的对象锁；

（2）wait方法是释放锁，notify方法是不释放锁的；
